# Лабораторная работа 02 - Основные структуры данных

**Дата:** 22.09.2025  
**Семестр:** 3 курс, 1 семестр  
**Группа:** ПИЖ-б-о-23-2-(2)
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Хаджимухаметов Саид Керимович

## Описание проекта

Проект реализует сравнительный анализ основных структур данных (список, связный список, дек) с экспериментальным подтверждением их временной сложности для различных операций.

## Цель работы

Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек, связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для решения конкретной задачи, основываясь на анализе теоретической и практической сложности операций.

## Теоретическая часть
- **Список (list) в Python**: Реализация динамического массива. Вставка в начало - O(n), вставка в конец - O(1), удаление из начала - O(n)
- **Связный список (Linked List)**: Структура из узлов с ссылками. Вставка/удаление в начало - O(1), доступ по индексу - O(n)
- **Дек (deque)**: Двусторонняя очередь. Все операции с начала/конца - O(1)
- **Стек (Stack)**: LIFO структура. Основные операции - O(1)
- **Очередь (Queue)**: FIFO структура. Основные операции - O(1)

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация класса LinkedList с основными операциями
- [x] Задача 2: Сравнительный анализ производительности list vs LinkedList vs deque
- [x] Задача 3: Решение практических задач (скобки, палиндром, очередь печати)
- [x] Задача 4: Визуализация результатов с построением графиков

### Ключевые фрагменты кода
```python
class LinkedList:
    def insert_at_start(self, data):
        """Вставка в начало. Сложность: O(1)"""
        new_node = Node(data)  # O(1)
        if self.head is None:  # O(1)
            self.head = self.tail = new_node  # O(1)
        else:
            new_node.next = self.head  # O(1)
            self.head = new_node       # O(1)
        self.size += 1  # O(1)

    def insert_at_end(self, data):
        """Вставка в конец. Сложность: O(1) с tail"""
        new_node = Node(data)  # O(1)
        if self.head is None:  # O(1)
            self.head = self.tail = new_node  # O(1)
        else:
            self.tail.next = new_node  # O(1)
            self.tail = new_node       # O(1)
        self.size += 1  # O(1)

def check_brackets_balance(expression):
    """Проверка скобок. Сложность: O(n)"""
    stack = []  # O(1)
    brackets = {')': '(', ']': '[', '}': '{'}  # O(1)
    
    for char in expression:  # O(n)
        if char in '([{':    # O(1)
            stack.append(char)  # O(1)
        elif char in brackets:  # O(1)
            if not stack or stack[-1] != brackets[char]:  # O(1)
                return False
            stack.pop()  # O(1)
    return len(stack) == 0  # O(1)
  ```

  ### Результат выполнения

  ```bash
    Характеристики ПК для тестирования:
    - Процессор: Intel Core i5-13400f 
    - Оперативная память: 16 GB
    - OC: Windows 11 PRO
    - Python: 3.12.8

Сравнение вставки в начало:
Размер | List (мс) | LinkedList (мс)
----------------------------------------
   100 |      0.04 |           0.10
   500 |      0.27 |           0.38
  1000 |      1.05 |           3.16
  2000 |      3.40 |           3.59
  5000 |     35.04 |           7.36

Сравнение удаления из начала (очередь):
Размер | List (мс) | Deque (мс)
----------------------------------------
   100 |      0.08 |       0.05
   500 |      0.24 |       0.22
  1000 |      0.69 |       0.35
  2000 |      5.67 |       1.58
  5000 |     14.90 |       3.28
  ```

  ## Выводы
  1. Связный список демонстрирует значительное преимущество при операциях вставки/удаления в начало (O(1) против O(n) у обычного списка)

  2. Дек (deque) является оптимальной структурой для реализации очереди, обеспечивая O(1) для операций с обоих концов

  3. Обычный список эффективен только для операций с концом массива и случайного доступа

  4. Для задач проверки сбалансированности скобок стек является естественным и эффективным решением

  5. Дек также эффективен для проверки палиндромов, позволяя сравнивать символы с обоих концов за O(1)

  ## Ответы на контрольные вопросы

  1. В чем ключевое отличие динамического массива (list в Python) от связного списка?
  - List: доступ по индексу O(1), вставка в начало O(n)
  - LinkedList: доступ по индексу O(n), вставка в начало O(1)

  2. Объясните принцип работы стека (LIFO) и очереди (FIFO). Примеры использования:
  - Стек (LIFO): последний пришел - первый ушел. Примеры: отмена действий, вызов функций
  - Очередь (FIFO): первый пришел - первый ушел. Примеры: очередь печати, обработка запросов

  3. Почему удаление из начала списка O(n), а из дека O(1)?
  - List требует сдвига всех элементов при удалении из начала
  - Deque использует циклический буфер, позволяющий O(1) операции с обоих концов

  4. Какую структуру выбрать для системы отмены действий?
  - Стек, так как отмена действий соответствует LIFO принципу

  5. Объясните разницу во времени вставки в начало list vs LinkedList:
  - List: O(n) из-за необходимости сдвига элементов
  - LinkedList: O(1) - просто изменение ссылок

## Приложения
Исходный код: linked_list.py, performance_analysis.py, task_solutions.py
Графики сравнения: performance_comparison.png

![Search Comparison](performance_comparison.png)

```python
#linked_list.py
class Node:
    """Узел связного списка."""
    
    def __init__(self, data):
        """
        Инициализация узла.
        
        Args:
            data: Данные для хранения в узле
        """
        self.data = data  # O(1) - присваивание
        self.next = None  # O(1) - присваивание


class LinkedList:
    """Односвязный список."""
    
    def __init__(self):
        """Инициализация пустого списка."""  # O(1) - инициализация
        self.head = None  # O(1) - присваивание
        self.tail = None  # O(1) - присваивание
        self.size = 0     # O(1) - присваивание
    
    def insert_at_start(self, data):
        """
        Вставка элемента в начало списка.
        
        Args:
            data: Данные для вставки
            
        Complexity: O(1)
        """
        new_node = Node(data)  # O(1) - создание узла
        
        if self.head is None:  # O(1) - проверка
            self.head = new_node  # O(1) - присваивание
            self.tail = new_node  # O(1) - присваивание
        else:
            new_node.next = self.head  # O(1) - присваивание
            self.head = new_node       # O(1) - присваивание
        
        self.size += 1  # O(1) - инкремент
    
    def insert_at_end(self, data):
        """
        Вставка элемента в конец списка.
        
        Args:
            data: Данные для вставки
            
        Complexity: O(1) - с использованием tail
        """
        new_node = Node(data)  # O(1) - создание узла
        
        if self.head is None:  # O(1) - проверка
            self.head = new_node  # O(1) - присваивание
            self.tail = new_node  # O(1) - присваивание
        else:
            self.tail.next = new_node  # O(1) - присваивание
            self.tail = new_node       # O(1) - присваивание
        
        self.size += 1  # O(1) - инкремент
    
    def delete_from_start(self):
        """
        Удаление элемента из начала списка.
        
        Returns:
            Удаленные данные или None если список пуст
            
        Complexity: O(1)
        """
        if self.head is None:  # O(1) - проверка
            return None
        
        data = self.head.data  # O(1) - доступ
        
        if self.head == self.tail:  # O(1) - проверка
            self.head = None  # O(1) - присваивание
            self.tail = None  # O(1) - присваивание
        else:
            self.head = self.head.next  # O(1) - присваивание
        
        self.size -= 1  # O(1) - декремент
        return data     # O(1) - возврат
    
    def traversal(self):
        """
        Обход всех элементов списка.
        
        Returns:
            Список всех элементов
            
        Complexity: O(n)
        """
        elements = []           # O(1) - создание списка
        current = self.head     # O(1) - присваивание
        
        while current:          # O(n) - цикл по всем элементам
            elements.append(current.data)  # O(1) - добавление в список
            current = current.next         # O(1) - переход к следующему
        
        return elements  # O(1) - возврат
    
    def is_empty(self):
        """
        Проверка пустоты списка.
        
        Returns:
            True если список пуст, иначе False
            
        Complexity: O(1)
        """
        return self.head is None  # O(1) - проверка


# Общая сложность класса: зависит от вызываемых методов
```

```python
#performance_analysis.py
import timeit
import matplotlib.pyplot as plt
from collections import deque
from linked_list import LinkedList


def measure_list_insert_start(n):
    """
    Измерение времени вставки в начало списка.
    
    Args:
        n: Количество элементов для вставки
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        lst = []  # O(1) - создание списка
        for i in range(n):  # O(n) - цикл
            lst.insert(0, i)  # O(n) - вставка в начало
    
    time_taken = timeit.timeit(operation, number=1)  # O(n^2) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def measure_linked_list_insert_start(n):
    """
    Измерение времени вставки в начало связного списка.
    
    Args:
        n: Количество элементов для вставки
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        ll = LinkedList()  # O(1) - создание списка
        for i in range(n):  # O(n) - цикл
            ll.insert_at_start(i)  # O(1) - вставка в начало
    
    time_taken = timeit.timeit(operation, number=1)  # O(n) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def measure_list_dequeue(n):
    """
    Измерение времени удаления из начала списка.
    
    Args:
        n: Количество операций удаления
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        lst = list(range(n))  # O(n) - создание списка
        for _ in range(n):  # O(n) - цикл
            if lst:  # O(1) - проверка
                lst.pop(0)  # O(n) - удаление из начала
    
    time_taken = timeit.timeit(operation, number=1)  # O(n^2) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def measure_deque_dequeue(n):
    """
    Измерение времени удаления из начала дека.
    
    Args:
        n: Количество операций удаления
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        dq = deque(range(n))  # O(n) - создание дека
        for _ in range(n):  # O(n) - цикл
            if dq:  # O(1) - проверка
                dq.popleft()  # O(1) - удаление из начала
    
    time_taken = timeit.timeit(operation, number=1)  # O(n) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def run_performance_analysis():
    """Запуск анализа производительности."""
    # Характеристики ПК для тестирования
    pc_info = """
    Характеристики ПК для тестирования:
    - Процессор: Intel Core i7-6500U @ 2.50GHz
    - Оперативная память: 8 GB
    - OC: Windows 10 PRO
    - Python: 3.12.8
    """
    print(pc_info)
    
    # Тестируемые размеры
    sizes = [100, 500, 1000, 2000, 5000]
    
    # Результаты измерений
    list_insert_times = []
    linked_list_insert_times = []
    list_dequeue_times = []
    deque_dequeue_times = []
    
    print('Сравнение вставки в начало:')
    print('Размер | List (мс) | LinkedList (мс)')
    print('-' * 40)
    
    for size in sizes:
        list_time = measure_list_insert_start(size)
        linked_list_time = measure_linked_list_insert_start(size)
        
        list_insert_times.append(list_time)
        linked_list_insert_times.append(linked_list_time)
        
        print(f'{size:6} | {list_time:9.2f} | {linked_list_time:14.2f}')
    
    print('\nСравнение удаления из начала (очередь):')
    print('Размер | List (мс) | Deque (мс)')
    print('-' * 40)
    
    for size in sizes:
        list_time = measure_list_dequeue(size)
        deque_time = measure_deque_dequeue(size)
        
        list_dequeue_times.append(list_time)
        deque_dequeue_times.append(deque_time)
        
        print(f'{size:6} | {list_time:9.2f} | {deque_time:10.2f}')
    
    # Построение графиков
    plt.figure(figsize=(12, 5))
    
    # График 1: Сравнение вставки в начало
    plt.subplot(1, 2, 1)
    plt.plot(sizes, list_insert_times, 'ro-', label='List insert(0)')
    plt.plot(sizes, linked_list_insert_times, 'bo-', label='LinkedList insert_at_start')
    plt.xlabel('Количество элементов')
    plt.ylabel('Время (мс)')
    plt.title('Вставка в начало\nList: O(n²) vs LinkedList: O(n)')
    plt.legend()
    plt.grid(True)
    
    # График 2: Сравнение удаления из начала
    plt.subplot(1, 2, 2)
    plt.plot(sizes, list_dequeue_times, 'ro-', label='List pop(0)')
    plt.plot(sizes, deque_dequeue_times, 'go-', label='Deque popleft()')
    plt.xlabel('Количество элементов')
    plt.ylabel('Время (мс)')
    plt.title('Удаление из начала\nList: O(n²) vs Deque: O(n)')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.savefig('performance_comparison.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return {
        'sizes': sizes,
        'list_insert': list_insert_times,
        'linked_list_insert': linked_list_insert_times,
        'list_dequeue': list_dequeue_times,
        'deque_dequeue': deque_dequeue_times
    }


if __name__ == '__main__':
    results = run_performance_analysis()
```

```python
#task_solutions.py
from collections import deque
from linked_list import LinkedList


def check_brackets_balance(expression):
    """
    Проверка сбалансированности скобок с использованием стека.
    
    Args:
        expression: Строка со скобками
        
    Returns:
        True если скобки сбалансированы, иначе False
        
    Complexity: O(n)
    """
    stack = []  # O(1) - создание стека
    brackets = {')': '(', ']': '[', '}': '{'}  # O(1) - создание словаря
    
    for char in expression:  # O(n) - цикл по символам
        if char in '([{':  # O(1) - проверка
            stack.append(char)  # O(1) - добавление в стек
        elif char in brackets:  # O(1) - проверка
            if not stack or stack[-1] != brackets[char]:  # O(1) - проверка
                return False  # O(1) - возврат
            stack.pop()  # O(1) - удаление из стека
    
    return len(stack) == 0  # O(1) - проверка и возврат


def is_palindrome_deque(text):
    """
    Проверка строки на палиндром с использованием дека.
    
    Args:
        text: Строка для проверки
        
    Returns:
        True если строка - палиндром, иначе False
        
    Complexity: O(n)
    """
    # Очистка строки от пробелов и приведение к нижнему регистру
    cleaned = ''.join(char.lower() for char in text if char.isalnum())  # O(n)
    
    dq = deque(cleaned)  # O(n) - создание дека
    
    while len(dq) > 1:  # O(n) - цикл
        if dq.popleft() != dq.pop():  # O(1) - сравнение
            return False  # O(1) - возврат
    
    return True  # O(1) - возврат


class PrintQueue:
    """Очередь печати на основе deque."""
    
    def __init__(self):
        """Инициализация очереди."""  # O(1) - инициализация
        self.queue = deque()  # O(1) - создание дека
    
    def enqueue(self, task):
        """
        Добавление задачи в очередь.
        
        Args:
            task: Задача для печати
            
        Complexity: O(1)
        """
        self.queue.append(task)  # O(1) - добавление в конец
    
    def dequeue(self):
        """
        Извлечение задачи из очереди.
        
        Returns:
            Задача или None если очередь пуста
            
        Complexity: O(1)
        """
        if self.queue:  # O(1) - проверка
            return self.queue.popleft()  # O(1) - удаление из начала
        return None  # O(1) - возврат
    
    def process_queue(self):
        """
        Обработка всех задач в очереди.
        
        Complexity: O(n)
        """
        print('Обработка очереди печати:')
        while self.queue:  # O(n) - цикл
            task = self.dequeue()  # O(1) - извлечение
            print(f'Печатается: {task}')  # O(1) - вывод
        print('Все задачи обработаны.')  # O(1) - вывод
    
    def is_empty(self):
        """
        Проверка пустоты очереди.
        
        Returns:
            True если очередь пуста, иначе False
            
        Complexity: O(1)
        """
        return len(self.queue) == 0  # O(1) - проверка


def test_practical_tasks():
    """Тестирование практических задач."""
    # Тест проверки скобок
    test_expressions = [
        '()',
        '()[]{}',
        '([{}])',
        '(]',
        '([)]',
        '((()'
    ]
    
    print('Проверка сбалансированности скобок:')
    for expr in test_expressions:
        result = check_brackets_balance(expr)
        print(f'"{expr}" -> {"Сбалансированы" if result else "Не сбалансированы"}')
    
    print('\n' + '='*50 + '\n')
    
    # Тест проверки палиндромов
    test_strings = [
        'А роза упала на лапу Азора',
        'racecar',
        'hello',
        'Madam, I\'m Adam',
        'not a palindrome'
    ]
    
    print('Проверка палиндромов:')
    for text in test_strings:
        result = is_palindrome_deque(text)
        print(f'"{text}" -> {"Палиндром" if result else "Не палиндром"}')
    
    print('\n' + '='*50 + '\n')
    
    # Тест очереди печати
    print('Симуляция очереди печати:')
    print_queue = PrintQueue()
    
    # Добавляем задачи в очередь
    tasks = ['Документ1.pdf', 'Отчет.docx', 'Презентация.pptx', 'Изображение.jpg']
    for task in tasks:
        print_queue.enqueue(task)
        print(f'Добавлено в очередь: {task}')
    
    print()
    print_queue.process_queue()


if __name__ == '__main__':
    test_practical_tasks()
```
  
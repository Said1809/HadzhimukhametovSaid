"""
Модуль: tree_traversal.py
Описание: Реализация различных методов обхода бинарного дерева поиска
          (рекурсивные и итеративные варианты).
"""
from binary_search_tree import BinarySearchTree  # O(1)

# Рекурсивные обходы

def in_order(node):  # O(n)
    """
    Обход дерева в порядке: левое поддерево -> корень -> правое поддерево.
    Для BST дает отсортированный порядок элементов.
    Параметры: node - текущий узел дерева
    Сложность: O(n), так как посещаются все n узлов
    """
    if node:  # O(1)
        in_order(node.left)  # O(n) для левого поддерева
        print(node.value, end=" ")  # O(1)
        in_order(node.right)  # O(n) для правого поддерева

def pre_order(node):  # O(n)
    """
    Обход дерева в порядке: корень -> левое поддерево -> правое поддерево.
    Используется для копирования дерева.
    Параметры: node - текущий узел дерева
    Сложность: O(n), так как посещаются все n узлов
    """
    if node:  # O(1)
        print(node.value, end=" ")  # O(1)
        pre_order(node.left)  # O(n) для левого поддерева
        pre_order(node.right)  # O(n) для правого поддерева

def post_order(node):  # O(n)
    """
    Обход дерева в порядке: левое поддерево -> правое поддерево -> корень.
    Используется для удаления дерева.
    Параметры: node - текущий узел дерева
    Сложность: O(n), так как посещаются все n узлов
    """
    if node:  # O(1)
        post_order(node.left)  # O(n) для левого поддерева
        post_order(node.right)  # O(n) для правого поддерева
        print(node.value, end=" ")  # O(1)

# Итеративный обход с использованием стека

def in_order_iterative(root):  # O(n)
    """
    Итеративный обход дерева в порядке: левое -> корень -> правое (используя стек).
    Альтернатива рекурсивному подходу, избегает переполнения стека при глубоких деревьях.
    Параметры: root - корень дерева
    Сложность: O(n) - посещаются все n узлов, каждый узел посещается один раз
    Память: O(h) - стек содержит до h узлов, где h - высота дерева
    """
    stack = []  # O(1) - инициализация стека
    current = root  # O(1) - инициализация текущего узла
    while stack or current:  # O(n) - основной цикл, выполняется для каждого узла
        while current:  # O(h) - спуск вниз по левому краю, высота дерева
            stack.append(current)  # O(1) - добавление в стек
            current = current.left  # O(1) - переход к левому потомку
        current = stack.pop()  # O(1) - извлечение из стека
        print(current.value, end=" ")  # O(1) - вывод значения узла
        current = current.right  # O(1) - переход к правому поддереву
